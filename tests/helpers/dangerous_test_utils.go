package helpers

import (
	"path/filepath"
	"testing"
	
	"github.com/mojosolo/mobot2025/catalog"
)

// RunDangerousAnalysis runs the DangerousAnalyzer on a real AEP file
func RunDangerousAnalysis(t *testing.T, filename string) *catalog.DeepAnalysisResult {
	t.Helper()
	
	// Create analyzer
	analyzer := catalog.NewDangerousAnalyzer()
	
	// Get real file path
	path := GetRealAEPPath(filename)
	
	// Run dangerous deep analysis
	result, err := analyzer.AnalyzeProject(path)
	if err != nil {
		t.Fatalf("Failed to perform dangerous analysis on %s: %v", filename, err)
	}
	
	return result
}

// AnalyzeAllRealFiles runs dangerous analysis on all real AEP files
func AnalyzeAllRealFiles(t *testing.T) map[string]*catalog.DeepAnalysisResult {
	t.Helper()
	
	results := make(map[string]*catalog.DeepAnalysisResult)
	
	for _, filename := range GetAllRealAEPFiles() {
		t.Run(filename, func(t *testing.T) {
			result := RunDangerousAnalysis(t, filename)
			results[filename] = result
			
			// Log interesting findings
			t.Logf("File: %s", filename)
			t.Logf("  Complexity Score: %.2f", result.ComplexityScore)
			t.Logf("  Automation Score: %.2f", result.AutomationScore)
			t.Logf("  Hidden Layers: %d", len(result.HiddenLayers))
			if result.ModularSystem != nil {
				t.Logf("  Modular Components: %d", result.ModularSystem.TotalModules)
			}
		})
	}
	
	return results
}

// FindHiddenPatterns uses DangerousAnalyzer to find hidden patterns in real files
func FindHiddenPatterns(t *testing.T, filename string) []catalog.HiddenLayer {
	t.Helper()
	
	result := RunDangerousAnalysis(t, filename)
	return result.HiddenLayers
}

// ExtractModularComponents finds modular components in real AEP files
func ExtractModularComponents(t *testing.T, filename string) *catalog.ModularSystemAnalysis {
	t.Helper()
	
	result := RunDangerousAnalysis(t, filename)
	return result.ModularSystem
}

// GenerateRealAPISchema generates an API schema from a real AEP file
func GenerateRealAPISchema(t *testing.T, filename string) *catalog.AutoGeneratedAPISchema {
	t.Helper()
	
	result := RunDangerousAnalysis(t, filename)
	return result.APISchema
}

// CompareRealFileComplexity compares complexity between real AEP files
func CompareRealFileComplexity(t *testing.T) {
	t.Helper()
	
	complexities := make(map[string]float64)
	
	for _, filename := range GetAllRealAEPFiles() {
		result := RunDangerousAnalysis(t, filename)
		complexities[filename] = result.ComplexityScore
	}
	
	// Find most and least complex
	var mostComplex, leastComplex string
	var maxScore, minScore float64 = 0, 100
	
	for file, score := range complexities {
		if score > maxScore {
			maxScore = score
			mostComplex = file
		}
		if score < minScore {
			minScore = score
			leastComplex = file
		}
	}
	
	t.Logf("Complexity Analysis:")
	t.Logf("  Most Complex: %s (%.2f)", mostComplex, maxScore)
	t.Logf("  Least Complex: %s (%.2f)", leastComplex, minScore)
}

// TestRealFileEdgeCases tests edge cases with real files
func TestRealFileEdgeCases(t *testing.T) {
	t.Helper()
	
	// Test with complex project
	complexPath := GetComplexRealAEPPath()
	parser := catalog.NewParser()
	
	metadata, err := parser.ParseProject(complexPath)
	if err != nil {
		t.Logf("Complex file parsing: %v (this may be expected)", err)
	} else {
		t.Logf("Complex file parsed successfully:")
		t.Logf("  Name: %s", filepath.Base(complexPath))
		t.Logf("  Compositions: %d", len(metadata.Compositions))
		t.Logf("  Text Layers: %d", len(metadata.TextLayers))
		t.Logf("  Media Assets: %d", len(metadata.MediaAssets))
	}
}