package aep

import (
	"fmt"
	"strings"
)

// TextDocument represents parsed text layer content
type TextDocument struct {
	Text           string
	FontName       string
	FontSize       float64
	FontStyle      string
	FillColor      [4]float32 // RGBA
	StrokeColor    [4]float32 // RGBA
	StrokeWidth    float32
	Justification  string
	Tracking       float32
	LineHeight     float32
	BaselineShift  float32
}

// TextKeyframe represents text at a specific time
type TextKeyframe struct {
	Time     float64
	Document TextDocument
}

// ExtractTextContent extracts text content from a text layer's property tree
func ExtractTextContent(textProperty *Property) (*TextDocument, error) {
	if textProperty == nil {
		return nil, fmt.Errorf("text property is nil")
	}
	
	doc := &TextDocument{
		// Default values
		FontName: "Arial",
		FontSize: 12.0,
		FillColor: [4]float32{1, 1, 1, 1}, // White
		StrokeColor: [4]float32{0, 0, 0, 1}, // Black
	}
	
	// Navigate through the property tree to find text data
	if err := extractFromPropertyTree(textProperty, doc); err != nil {
		return nil, err
	}
	
	// If we still don't have text, check the ADBE Text Document child directly
	if doc.Text == "" {
		for _, child := range textProperty.Properties {
			if child.MatchName == "ADBE Text Document" {
				// The text might be in a keyframe or expression
				// For now, we'll note that this is where text content should be
				doc.Text = "[Text content in keyframes/expressions]"
				break
			}
		}
	}
	
	return doc, nil
}

// extractFromPropertyTree recursively searches for text data in the property tree
func extractFromPropertyTree(prop *Property, doc *TextDocument) error {
	if prop == nil {
		return nil
	}
	
	// Check common text property match names
	switch prop.MatchName {
	case "ADBE Text Document":
		// This usually contains the actual text
		if err := parseTextDocument(prop, doc); err != nil {
			return err
		}
		
	case "ADBE Source Text":
		// Alternative location for text content
		if err := parseSourceText(prop, doc); err != nil {
			return err
		}
		
	case "ADBE Text Properties":
		// Root text properties, search children
		for _, child := range prop.Properties {
			if err := extractFromPropertyTree(child, doc); err != nil {
				return err
			}
		}
		
	case "ADBE Text Animators":
		// Text animators may contain text modifications
		// TODO: Handle animated text
		
	default:
		// Search in child properties
		for _, child := range prop.Properties {
			if err := extractFromPropertyTree(child, doc); err != nil {
				return err
			}
		}
	}
	
	// Also check property name for clues
	if strings.Contains(strings.ToLower(prop.Name), "text") ||
	   strings.Contains(strings.ToLower(prop.Name), "source") {
		// Try to extract text from this property
		parsePropertyData(prop, doc)
	}
	
	return nil
}

// parseTextDocument parses ADBE Text Document property
func parseTextDocument(prop *Property, doc *TextDocument) error {
	// Text documents in AEP files are typically stored as:
	// 1. String data in property labels or names
	// 2. Binary data in keyframe values
	// 3. Expression strings
	
	// Check if text is in the label (user-entered text)
	if prop.Label != "" && prop.Label != "-_0_/-" {
		doc.Text = prop.Label
	}
	
	// TODO: Parse binary text document format
	// This would require analyzing the binary structure of text documents
	// which varies based on After Effects version
	
	return nil
}

// parseSourceText parses ADBE Source Text property
func parseSourceText(prop *Property, doc *TextDocument) error {
	// Source text might be in various formats
	
	// Check direct property values
	if prop.Name != "" && prop.Name != prop.MatchName {
		// Sometimes the text is stored directly in the name
		doc.Text = prop.Name
	}
	
	// Check select options (for expression-based text)
	if len(prop.SelectOptions) > 0 {
		doc.Text = strings.Join(prop.SelectOptions, " ")
	}
	
	return nil
}

// parsePropertyData attempts to extract text from generic property data
func parsePropertyData(prop *Property, doc *TextDocument) {
	// Try various heuristics to find text
	
	// Check if property name contains actual text
	if prop.Name != "" && prop.Name != prop.MatchName {
		// Filter out property names that are clearly not text content
		if !strings.HasPrefix(prop.Name, "ADBE") && 
		   !strings.Contains(prop.Name, "::") &&
		   len(prop.Name) > 3 {
			// This might be actual text content
			if doc.Text == "" {
				doc.Text = prop.Name
			}
		}
	}
	
	// Check label
	if prop.Label != "" && prop.Label != "-_0_/-" {
		if doc.Text == "" {
			doc.Text = prop.Label
		}
	}
	
	// Check raw data
	if len(prop.RawData) > 0 && doc.Text == "" {
		// Try to parse as UTF-8 string
		text := string(prop.RawData)
		// Clean up the text
		text = strings.TrimSpace(text)
		if text != "" && !strings.HasPrefix(text, "ADBE") {
			doc.Text = text
		}
	}
}

// ExtractAllTextLayers finds all text layers in a project and extracts their content
func ExtractAllTextLayers(project *Project) map[string][]*TextDocument {
	textByComp := make(map[string][]*TextDocument)
	
	for _, item := range project.Items {
		if item.ItemType == ItemTypeComposition {
			compTexts := make([]*TextDocument, 0)
			
			for _, layer := range item.CompositionLayers {
				if layer.Text != nil {
					// This is a text layer
					doc, err := ExtractTextContent(layer.Text)
					if err == nil && doc != nil {
						// Try to get better text if current is empty
						if doc.Text == "" {
							// Use layer name as fallback
							if strings.Contains(strings.ToLower(layer.Name), "text") ||
							   strings.Contains(strings.ToLower(layer.Name), "title") ||
							   strings.Contains(strings.ToLower(layer.Name), "placeholder") {
								doc.Text = fmt.Sprintf("[%s]", layer.Name)
							}
						}
						compTexts = append(compTexts, doc)
					}
				}
			}
			
			if len(compTexts) > 0 {
				textByComp[item.Name] = compTexts
			}
		}
	}
	
	return textByComp
}

// Helper function to parse binary font data (placeholder for future implementation)
func parseFontData(data []byte, doc *TextDocument) error {
	// TODO: Implement binary font data parsing
	// AEP files store font information in a binary format that needs reverse engineering
	
	// Basic structure (guessed):
	// - Font name as UTF-8 string
	// - Font size as float32
	// - Style flags as uint32
	// - Colors as float32 arrays
	
	if len(data) < 4 {
		return fmt.Errorf("insufficient data for font parsing")
	}
	
	// This is a placeholder - actual implementation would need to reverse engineer
	// the binary format through experimentation
	
	return nil
}

// ParseTextExpression parses text that comes from expressions
func ParseTextExpression(expression string) string {
	// Simple expression parsing
	// Real expressions would need JavaScript evaluation
	
	// Remove common expression syntax
	expression = strings.TrimSpace(expression)
	expression = strings.TrimPrefix(expression, "\"")
	expression = strings.TrimSuffix(expression, "\"")
	expression = strings.TrimPrefix(expression, "'")
	expression = strings.TrimSuffix(expression, "'")
	
	return expression
}