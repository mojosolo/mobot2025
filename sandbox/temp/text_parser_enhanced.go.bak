package aep

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"strings"
	"unicode/utf8"
)

// EnhancedTextDocument represents fully parsed text layer content
type EnhancedTextDocument struct {
	Text           string
	FontName       string
	FontSize       float64
	FontStyle      string
	FillColor      [4]float32 // RGBA
	StrokeColor    [4]float32 // RGBA
	StrokeWidth    float32
	Justification  string
	Tracking       float32
	LineHeight     float32
	BaselineShift  float32
	IsAnimated     bool
	Keyframes      []TextKeyframe
}

// TextDocumentBinary represents the binary structure of text documents in AEP files
type TextDocumentBinary struct {
	// The actual structure varies by version, but typically includes:
	// - Magic bytes/version
	// - Text length
	// - Text content (UTF-16 or UTF-8)
	// - Font information
	// - Style information
}

// ExtractEnhancedTextContent provides improved text extraction from text layers
func ExtractEnhancedTextContent(textProperty *Property) (*EnhancedTextDocument, error) {
	if textProperty == nil {
		return nil, fmt.Errorf("text property is nil")
	}
	
	doc := &EnhancedTextDocument{
		// Default values
		FontName: "Arial",
		FontSize: 12.0,
		FillColor: [4]float32{1, 1, 1, 1}, // White
		StrokeColor: [4]float32{0, 0, 0, 1}, // Black
	}
	
	// Navigate through the property tree to find text data
	if err := extractEnhancedFromPropertyTree(textProperty, doc); err != nil {
		return nil, err
	}
	
	// If we still don't have text, try more aggressive extraction
	if doc.Text == "" {
		doc.Text = extractTextFromRawData(textProperty)
	}
	
	return doc, nil
}

// extractEnhancedFromPropertyTree recursively searches for text data with enhanced parsing
func extractEnhancedFromPropertyTree(prop *Property, doc *EnhancedTextDocument) error {
	if prop == nil {
		return nil
	}
	
	// Debug logging
	// fmt.Printf("Checking property: %s (%s)\n", prop.MatchName, prop.Name)
	
	switch prop.MatchName {
	case "ADBE Text Document":
		// This is the main text document property
		parseEnhancedTextDocument(prop, doc)
		
	case "ADBE Source Text":
		// Alternative location for text content
		parseEnhancedSourceText(prop, doc)
		
	case "ADBE Text Properties":
		// Root text properties, search children
		for _, child := range prop.Properties {
			extractEnhancedFromPropertyTree(child, doc)
		}
		
	case "ADBE Text Animators":
		// Text animators may contain text modifications
		doc.IsAnimated = true
		
	default:
		// Check if this property might contain text data
		if strings.Contains(prop.MatchName, "Text") || 
		   strings.Contains(prop.MatchName, "Source") ||
		   strings.Contains(prop.Name, "Text") {
			// Try to extract from raw data
			if len(prop.RawData) > 0 {
				text := extractTextFromBytes(prop.RawData)
				if text != "" && doc.Text == "" {
					doc.Text = text
				}
			}
		}
		
		// Search in child properties
		for _, child := range prop.Properties {
			extractEnhancedFromPropertyTree(child, doc)
		}
	}
	
	return nil
}

// parseEnhancedTextDocument parses ADBE Text Document property with binary data support
func parseEnhancedTextDocument(prop *Property, doc *EnhancedTextDocument) {
	// First check for simple text in various fields
	if prop.Label != "" && prop.Label != "-_0_/-" {
		doc.Text = prop.Label
	} else if prop.Name != "" && prop.Name != prop.MatchName && !strings.HasPrefix(prop.Name, "ADBE") {
		doc.Text = prop.Name
	}
	
	// Check raw data for binary text document
	if len(prop.RawData) > 0 {
		text := parseTextDocumentBinary(prop.RawData)
		if text != "" {
			doc.Text = text
		}
	}
	
	// Look for keyframe data in child properties
	for _, child := range prop.Properties {
		if strings.Contains(child.MatchName, "Keyframe") || 
		   strings.Contains(child.MatchName, "Key") {
			// This might contain keyframe data
			if len(child.RawData) > 0 {
				// Try to parse keyframe text
				text := extractTextFromBytes(child.RawData)
				if text != "" && doc.Text == "" {
					doc.Text = text
				}
			}
		}
	}
}

// parseEnhancedSourceText parses ADBE Source Text property
func parseEnhancedSourceText(prop *Property, doc *EnhancedTextDocument) {
	// Check direct property values
	if prop.Name != "" && prop.Name != prop.MatchName && !strings.HasPrefix(prop.Name, "ADBE") {
		doc.Text = prop.Name
	}
	
	// Check select options (for expression-based text)
	if len(prop.SelectOptions) > 0 {
		doc.Text = strings.Join(prop.SelectOptions, " ")
	}
	
	// Check raw data
	if len(prop.RawData) > 0 {
		text := extractTextFromBytes(prop.RawData)
		if text != "" && doc.Text == "" {
			doc.Text = text
		}
	}
}

// parseTextDocumentBinary attempts to parse the binary format of text documents
func parseTextDocumentBinary(data []byte) string {
	if len(data) < 8 {
		return ""
	}
	
	// Try different parsing strategies
	
	// Strategy 1: Look for UTF-16 encoded text (common in Windows AEP files)
	if text := extractUTF16Text(data); text != "" {
		return text
	}
	
	// Strategy 2: Look for UTF-8 text blocks
	if text := extractUTF8Text(data); text != "" {
		return text
	}
	
	// Strategy 3: Look for null-terminated strings
	if text := extractNullTerminatedString(data); text != "" {
		return text
	}
	
	// Strategy 4: Try to find text after specific markers
	if text := extractTextAfterMarkers(data); text != "" {
		return text
	}
	
	return ""
}

// extractUTF16Text attempts to extract UTF-16 encoded text
func extractUTF16Text(data []byte) string {
	// Look for UTF-16 BOM or patterns
	for i := 0; i < len(data)-4; i++ {
		// Check for possible UTF-16 LE text (every other byte is 0 for ASCII)
		if i+20 < len(data) && data[i+1] == 0 && data[i+3] == 0 && data[i+5] == 0 {
			// Might be UTF-16 LE
			end := i
			for j := i; j < len(data)-1; j += 2 {
				if data[j] == 0 && data[j+1] == 0 {
					end = j
					break
				}
			}
			
			if end > i+4 {
				// Try to decode UTF-16 LE
				textBytes := data[i:end]
				text := decodeUTF16LE(textBytes)
				if isValidText(text) {
					return text
				}
			}
		}
	}
	
	return ""
}

// extractUTF8Text attempts to extract UTF-8 encoded text
func extractUTF8Text(data []byte) string {
	// Look for consecutive valid UTF-8 characters
	for i := 0; i < len(data); i++ {
		if utf8.Valid(data[i:]) {
			// Find the longest valid UTF-8 sequence
			for j := len(data); j > i+4; j-- {
				if utf8.Valid(data[i:j]) {
					text := string(data[i:j])
					text = cleanTextString(text)
					if isValidText(text) {
						return text
					}
				}
			}
		}
	}
	
	return ""
}

// extractNullTerminatedString extracts null-terminated strings
func extractNullTerminatedString(data []byte) string {
	for i := 0; i < len(data)-4; i++ {
		// Look for printable ASCII followed by null
		if data[i] >= 32 && data[i] <= 126 {
			end := bytes.IndexByte(data[i:], 0)
			if end > 4 {
				text := string(data[i : i+end])
				if isValidText(text) {
					return text
				}
			}
		}
	}
	
	return ""
}

// extractTextAfterMarkers looks for text after known markers
func extractTextAfterMarkers(data []byte) string {
	// Common markers that might precede text in AEP files
	markers := [][]byte{
		[]byte("TEXT"),
		[]byte("text"),
		[]byte("Utf8"),
		[]byte("utf8"),
		[]byte{0x00, 0x00, 0x00}, // Common padding before text
	}
	
	for _, marker := range markers {
		idx := bytes.Index(data, marker)
		if idx >= 0 && idx+len(marker)+4 < len(data) {
			// Skip marker and some potential header bytes
			start := idx + len(marker)
			
			// Skip any leading nulls or small values
			for start < len(data) && data[start] < 32 {
				start++
			}
			
			if start < len(data)-4 {
				text := extractTextFromBytes(data[start:])
				if text != "" {
					return text
				}
			}
		}
	}
	
	return ""
}

// extractTextFromBytes is a general-purpose text extractor
func extractTextFromBytes(data []byte) string {
	if len(data) == 0 {
		return ""
	}
	
	// First, try direct UTF-8 conversion
	if utf8.Valid(data) {
		text := cleanTextString(string(data))
		if isValidText(text) {
			return text
		}
	}
	
	// Try to find sequences of printable characters
	var result []byte
	inText := false
	
	for i := 0; i < len(data); i++ {
		if isPrintable(data[i]) {
			if !inText {
				inText = true
			}
			result = append(result, data[i])
		} else if inText && len(result) > 4 {
			// End of text sequence
			text := cleanTextString(string(result))
			if isValidText(text) {
				return text
			}
			result = nil
			inText = false
		} else if inText {
			result = nil
			inText = false
		}
	}
	
	// Check final result
	if len(result) > 4 {
		text := cleanTextString(string(result))
		if isValidText(text) {
			return text
		}
	}
	
	return ""
}

// extractTextFromRawData attempts to extract text from any raw data in the property tree
func extractTextFromRawData(prop *Property) string {
	// Check the property's own raw data
	if len(prop.RawData) > 0 {
		if text := parseTextDocumentBinary(prop.RawData); text != "" {
			return text
		}
	}
	
	// Check all child properties for raw data
	for _, child := range prop.Properties {
		if text := extractTextFromRawData(child); text != "" {
			return text
		}
	}
	
	return ""
}

// Helper functions

func decodeUTF16LE(data []byte) string {
	if len(data)%2 != 0 {
		data = data[:len(data)-1]
	}
	
	runes := make([]rune, 0, len(data)/2)
	for i := 0; i < len(data); i += 2 {
		r := rune(binary.LittleEndian.Uint16(data[i : i+2]))
		if r > 0 {
			runes = append(runes, r)
		}
	}
	
	return string(runes)
}

func isPrintable(b byte) bool {
	return (b >= 32 && b <= 126) || b == '\n' || b == '\r' || b == '\t'
}

func cleanTextString(s string) string {
	// Remove null characters and trim
	s = strings.ReplaceAll(s, "\x00", "")
	s = strings.TrimSpace(s)
	
	// Remove any non-printable characters except newlines and tabs
	var result []rune
	for _, r := range s {
		if r >= 32 || r == '\n' || r == '\r' || r == '\t' {
			result = append(result, r)
		}
	}
	
	return string(result)
}

func isValidText(s string) bool {
	if len(s) < 1 {
		return false
	}
	
	// Check if it's likely to be actual text content
	// Reject strings that look like property names or technical identifiers
	if strings.HasPrefix(s, "ADBE") ||
		strings.HasPrefix(s, "tdbs") ||
		strings.HasPrefix(s, "pard") ||
		strings.Contains(s, "::") ||
		strings.HasPrefix(s, "-_") {
		return false
	}
	
	// Count printable characters
	printableCount := 0
	for _, r := range s {
		if r >= 32 && r <= 126 {
			printableCount++
		}
	}
	
	// At least 50% should be printable
	return float64(printableCount)/float64(len(s)) > 0.5
}