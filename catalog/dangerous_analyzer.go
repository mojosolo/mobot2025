// Package catalog provides dangerous deep analysis capabilities for AEP files
package catalog

import (
	"crypto/md5"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"
)

// DangerousAnalyzer performs deep, aggressive analysis of AEP projects
type DangerousAnalyzer struct {
	parser           *Parser
	enableJSX        bool
	extractHidden    bool
	findModular      bool
	generateSchemas  bool
}

// DeepAnalysisResult contains comprehensive analysis findings
type DeepAnalysisResult struct {
	Metadata         *ProjectMetadata               `json:"metadata"`
	ModularSystem    *ModularSystemAnalysis         `json:"modular_system"`
	HiddenLayers     []HiddenLayer                  `json:"hidden_layers"`
	TextIntelligence *TextLayerIntelligence         `json:"text_intelligence"`
	MediaMapping     *MediaReplacementMapping       `json:"media_mapping"`
	EffectChains     []EffectChain                  `json:"effect_chains"`
	APISchema        *AutoGeneratedAPISchema        `json:"api_schema"`
	ComplexityScore  float64                        `json:"complexity_score"`
	AutomationScore  float64                        `json:"automation_score"`
	Recommendations  []AutomationRecommendation     `json:"recommendations"`
}

// ModularSystemAnalysis represents discovered modular opportunities
type ModularSystemAnalysis struct {
	TotalModules      int                    `json:"total_modules"`
	ModularComponents []ModularComponent     `json:"modular_components"`
	Relationships     []ComponentRelationship `json:"relationships"`
	MixMatchOptions   []MixMatchOption       `json:"mix_match_options"`
	VariantPotential  int                    `json:"variant_potential"`
}

// ModularComponent represents a reusable component
type ModularComponent struct {
	ID              string   `json:"id"`
	Name            string   `json:"name"`
	Type            string   `json:"type"`
	Duration        float64  `json:"duration"`
	Dependencies    []string `json:"dependencies"`
	Customizable    bool     `json:"customizable"`
	UsageFrequency  int      `json:"usage_frequency"`
	ComplexityLevel string   `json:"complexity_level"`
}

// ComponentRelationship defines how components relate
type ComponentRelationship struct {
	ParentID     string `json:"parent_id"`
	ChildID      string `json:"child_id"`
	Relationship string `json:"relationship"` // nested, referenced, linked
	Strength     int    `json:"strength"`     // 1-10
}

// MixMatchOption represents a valid combination
type MixMatchOption struct {
	Name        string   `json:"name"`
	Components  []string `json:"components"`
	Duration    float64  `json:"duration"`
	Description string   `json:"description"`
}

// HiddenLayer represents layers not visible but influential
type HiddenLayer struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	Type       string                 `json:"type"`
	Properties map[string]interface{} `json:"properties"`
	Impact     string                 `json:"impact"`
}

// TextLayerIntelligence provides smart text analysis
type TextLayerIntelligence struct {
	TotalTextLayers    int                      `json:"total_text_layers"`
	DynamicFields      []DynamicTextField       `json:"dynamic_fields"`
	PatternGroups      map[string][]string      `json:"pattern_groups"`
	FormattingOptions  []TextFormattingOption   `json:"formatting_options"`
	LocalizationReady  bool                     `json:"localization_ready"`
	DataBindingOptions []DataBindingOption      `json:"data_binding_options"`
}

// DynamicTextField represents an intelligently detected text field
type DynamicTextField struct {
	LayerID          string   `json:"layer_id"`
	FieldName        string   `json:"field_name"`
	DetectedType     string   `json:"detected_type"` // title, subtitle, date, price, etc.
	ValidationRegex  string   `json:"validation_regex"`
	DefaultValue     string   `json:"default_value"`
	MaxLength        int      `json:"max_length"`
	AllowedFormats   []string `json:"allowed_formats"`
	AnimationProfile string   `json:"animation_profile"`
}

// TextFormattingOption represents text styling choices
type TextFormattingOption struct {
	Name       string                 `json:"name"`
	Properties map[string]interface{} `json:"properties"`
	Preview    string                 `json:"preview"`
}

// DataBindingOption represents data source connections
type DataBindingOption struct {
	FieldID      string   `json:"field_id"`
	DataType     string   `json:"data_type"`
	SourcePath   string   `json:"source_path"`
	Transformer  string   `json:"transformer"`
	FallbackValue string  `json:"fallback_value"`
}

// MediaReplacementMapping maps all replaceable media
type MediaReplacementMapping struct {
	TotalAssets       int                    `json:"total_assets"`
	ReplaceableAssets []ReplaceableAsset     `json:"replaceable_assets"`
	AssetGroups       map[string][]string    `json:"asset_groups"`
	SmartSuggestions  []MediaSuggestion      `json:"smart_suggestions"`
}

// ReplaceableAsset represents a media asset that can be replaced
type ReplaceableAsset struct {
	ID              string                 `json:"id"`
	Name            string                 `json:"name"`
	Type            string                 `json:"type"`
	Dimensions      []int                  `json:"dimensions"`
	Duration        float64                `json:"duration,omitempty"`
	UsageLocations  []string               `json:"usage_locations"`
	Requirements    map[string]interface{} `json:"requirements"`
	ReplacementType string                 `json:"replacement_type"` // direct, smart, conditional
}

// MediaSuggestion provides intelligent replacement suggestions
type MediaSuggestion struct {
	AssetID     string   `json:"asset_id"`
	Suggestion  string   `json:"suggestion"`
	Reasoning   string   `json:"reasoning"`
	Confidence  float64  `json:"confidence"`
	Alternatives []string `json:"alternatives"`
}

// EffectChain represents a sequence of effects
type EffectChain struct {
	ID             string         `json:"id"`
	Name           string         `json:"name"`
	Effects        []EffectNode   `json:"effects"`
	Customizable   bool           `json:"customizable"`
	PerformanceImpact string      `json:"performance_impact"`
	PresetOptions  []EffectPreset `json:"preset_options"`
}

// EffectNode represents a single effect in a chain
type EffectNode struct {
	Name       string                 `json:"name"`
	Parameters map[string]interface{} `json:"parameters"`
	Keyframes  []Keyframe             `json:"keyframes"`
}

// Keyframe represents animation keyframe
type Keyframe struct {
	Time  float64     `json:"time"`
	Value interface{} `json:"value"`
	Easing string     `json:"easing"`
}

// EffectPreset represents a pre-configured effect setting
type EffectPreset struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Parameters  map[string]interface{} `json:"parameters"`
	Preview     string                 `json:"preview"`
}

// AutoGeneratedAPISchema represents the API for the template
type AutoGeneratedAPISchema struct {
	Version    string                 `json:"version"`
	Endpoints  []APIEndpoint          `json:"endpoints"`
	DataModels map[string]DataModel   `json:"data_models"`
	Examples   []APIExample           `json:"examples"`
}

// APIEndpoint represents a generated API endpoint
type APIEndpoint struct {
	Method      string                 `json:"method"`
	Path        string                 `json:"path"`
	Description string                 `json:"description"`
	Parameters  []APIParameter         `json:"parameters"`
	Response    map[string]interface{} `json:"response"`
}

// APIParameter represents an API parameter
type APIParameter struct {
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	Required    bool        `json:"required"`
	Default     interface{} `json:"default"`
	Description string      `json:"description"`
	Validation  string      `json:"validation"`
}

// DataModel represents a data structure
type DataModel struct {
	Name       string                 `json:"name"`
	Fields     map[string]FieldDef    `json:"fields"`
	Required   []string               `json:"required"`
	Examples   []interface{}          `json:"examples"`
}

// FieldDef defines a field in a data model
type FieldDef struct {
	Type        string      `json:"type"`
	Description string      `json:"description"`
	Default     interface{} `json:"default"`
	Validation  string      `json:"validation"`
}

// APIExample shows how to use the API
type APIExample struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Request     map[string]interface{} `json:"request"`
	Response    map[string]interface{} `json:"response"`
}

// AutomationRecommendation suggests automation opportunities
type AutomationRecommendation struct {
	Type        string  `json:"type"`
	Title       string  `json:"title"`
	Description string  `json:"description"`
	Impact      string  `json:"impact"`
	Effort      string  `json:"effort"`
	ROI         float64 `json:"roi"`
	Steps       []string `json:"steps"`
}

// NewDangerousAnalyzer creates an analyzer with all features enabled
func NewDangerousAnalyzer() *DangerousAnalyzer {
	return &DangerousAnalyzer{
		parser:          NewParser(),
		enableJSX:       true,
		extractHidden:   true,
		findModular:     true,
		generateSchemas: true,
	}
}

// AnalyzeProject performs comprehensive dangerous analysis
func (d *DangerousAnalyzer) AnalyzeProject(aepPath string) (*DeepAnalysisResult, error) {
	// First, use standard parser
	metadata, err := d.parser.ParseProject(aepPath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse project: %w", err)
	}

	result := &DeepAnalysisResult{
		Metadata:        metadata,
		HiddenLayers:    []HiddenLayer{},
		EffectChains:    []EffectChain{},
		Recommendations: []AutomationRecommendation{},
	}

	// Perform deep analyses
	if d.findModular {
		result.ModularSystem = d.analyzeModularSystem(metadata)
	}

	if d.extractHidden {
		result.HiddenLayers = d.findHiddenLayers(metadata)
	}

	result.TextIntelligence = d.analyzeTextIntelligence(metadata)
	result.MediaMapping = d.analyzeMediaMapping(metadata)
	result.EffectChains = d.analyzeEffectChains(metadata)

	if d.generateSchemas {
		result.APISchema = d.generateAPISchema(metadata, result)
	}

	// Calculate scores
	result.ComplexityScore = d.calculateComplexity(result)
	result.AutomationScore = d.calculateAutomationPotential(result)

	// Generate recommendations
	result.Recommendations = d.generateRecommendations(result)

	return result, nil
}

// analyzeModularSystem discovers modular components
func (d *DangerousAnalyzer) analyzeModularSystem(metadata *ProjectMetadata) *ModularSystemAnalysis {
	analysis := &ModularSystemAnalysis{
		TotalModules:      0,
		ModularComponents: []ModularComponent{},
		Relationships:     []ComponentRelationship{},
		MixMatchOptions:   []MixMatchOption{},
		VariantPotential:  1,
	}

	// Analyze each composition for modularity
	componentMap := make(map[string]*ModularComponent)
	
	for _, comp := range metadata.Compositions {
		// Check if composition follows modular naming pattern
		if d.isModularNaming(comp.Name) {
			component := ModularComponent{
				ID:              comp.ID,
				Name:            comp.Name,
				Type:            d.detectComponentType(comp.Name),
				Duration:        comp.Duration,
				Dependencies:    []string{},
				Customizable:    comp.LayerCount > 2,
				UsageFrequency:  1,
				ComplexityLevel: d.assessComplexity(comp),
			}
			
			analysis.ModularComponents = append(analysis.ModularComponents, component)
			componentMap[comp.ID] = &component
			analysis.TotalModules++
		}
	}

	// Find relationships between components
	analysis.Relationships = d.findComponentRelationships(componentMap, metadata)

	// Generate mix-match options
	if analysis.TotalModules > 2 {
		analysis.MixMatchOptions = d.generateMixMatchOptions(analysis.ModularComponents)
		analysis.VariantPotential = d.calculateVariantPotential(analysis)
	}

	return analysis
}

// isModularNaming checks if naming suggests modularity
func (d *DangerousAnalyzer) isModularNaming(name string) bool {
	modularPatterns := []string{
		`(?i)scene[-_\s]?\d+`,
		`(?i)module[-_\s]?\d+`,
		`(?i)section[-_\s]?\d+`,
		`(?i)part[-_\s]?\d+`,
		`(?i)(intro|middle|outro|end)`,
		`(?i)comp[-_\s]?\d+`,
		`(?i)variant[-_\s]?[a-z]`,
	}

	for _, pattern := range modularPatterns {
		if matched, _ := regexp.MatchString(pattern, name); matched {
			return true
		}
	}
	return false
}

// detectComponentType identifies the type of component
func (d *DangerousAnalyzer) detectComponentType(name string) string {
	name = strings.ToLower(name)
	
	switch {
	case strings.Contains(name, "intro"):
		return "intro"
	case strings.Contains(name, "outro") || strings.Contains(name, "end"):
		return "outro"
	case strings.Contains(name, "transition"):
		return "transition"
	case strings.Contains(name, "title"):
		return "title"
	case strings.Contains(name, "lower"):
		return "lower_third"
	case strings.Contains(name, "logo"):
		return "logo"
	case strings.Contains(name, "scene"):
		return "scene"
	default:
		return "module"
	}
}

// assessComplexity determines complexity level
func (d *DangerousAnalyzer) assessComplexity(comp CompositionInfo) string {
	score := 0
	
	if comp.LayerCount > 20 {
		score += 3
	} else if comp.LayerCount > 10 {
		score += 2
	} else {
		score += 1
	}
	
	if comp.Is3D {
		score += 2
	}
	
	if comp.HasEffects {
		score += 1
	}
	
	if score >= 5 {
		return "high"
	} else if score >= 3 {
		return "medium"
	}
	return "low"
}

// findComponentRelationships discovers how components relate
func (d *DangerousAnalyzer) findComponentRelationships(components map[string]*ModularComponent, metadata *ProjectMetadata) []ComponentRelationship {
	relationships := []ComponentRelationship{}
	
	// This would require deeper AEP analysis to find actual relationships
	// For now, we'll infer based on naming and order
	comps := metadata.Compositions
	
	for i := 0; i < len(comps)-1; i++ {
		if component1, ok := components[comps[i].ID]; ok {
			if component2, ok := components[comps[i+1].ID]; ok {
				rel := ComponentRelationship{
					ParentID:     component1.ID,
					ChildID:      component2.ID,
					Relationship: "sequential",
					Strength:     7,
				}
				relationships = append(relationships, rel)
			}
		}
	}
	
	return relationships
}

// generateMixMatchOptions creates valid combinations
func (d *DangerousAnalyzer) generateMixMatchOptions(components []ModularComponent) []MixMatchOption {
	options := []MixMatchOption{}
	
	// Group components by type
	typeGroups := make(map[string][]ModularComponent)
	for _, comp := range components {
		typeGroups[comp.Type] = append(typeGroups[comp.Type], comp)
	}
	
	// Generate standard combinations
	if intros, ok := typeGroups["intro"]; ok && len(intros) > 0 {
		if outros, ok := typeGroups["outro"]; ok && len(outros) > 0 {
			// Basic intro + outro combinations
			for _, intro := range intros {
				for _, outro := range outros {
					option := MixMatchOption{
						Name:        fmt.Sprintf("%s + %s", intro.Name, outro.Name),
						Components:  []string{intro.ID, outro.ID},
						Duration:    intro.Duration + outro.Duration,
						Description: "Simple intro/outro combination",
					}
					options = append(options, option)
				}
			}
		}
	}
	
	// Add scene-based combinations
	if scenes, ok := typeGroups["scene"]; ok && len(scenes) > 0 {
		// Multi-scene combinations
		if len(scenes) >= 3 {
			option := MixMatchOption{
				Name:        "Multi-Scene Story",
				Components:  []string{scenes[0].ID, scenes[1].ID, scenes[2].ID},
				Duration:    scenes[0].Duration + scenes[1].Duration + scenes[2].Duration,
				Description: "Three-scene narrative structure",
			}
			options = append(options, option)
		}
	}
	
	return options
}

// calculateVariantPotential calculates total possible variations
func (d *DangerousAnalyzer) calculateVariantPotential(analysis *ModularSystemAnalysis) int {
	// Simple calculation based on component types
	potential := 1
	
	typeCount := make(map[string]int)
	for _, comp := range analysis.ModularComponents {
		typeCount[comp.Type]++
	}
	
	for _, count := range typeCount {
		if count > 1 {
			potential *= count
		}
	}
	
	return potential
}

// findHiddenLayers discovers non-visible but important layers
func (d *DangerousAnalyzer) findHiddenLayers(metadata *ProjectMetadata) []HiddenLayer {
	hidden := []HiddenLayer{}
	
	// Look for adjustment layers, null objects, guides
	// This would require deeper binary analysis in real implementation
	
	// Simulate finding some hidden layers
	if len(metadata.Compositions) > 0 {
		hidden = append(hidden, HiddenLayer{
			ID:   "hidden_1",
			Name: "Master Color Controller",
			Type: "adjustment_layer",
			Properties: map[string]interface{}{
				"colorCorrection": true,
				"effects": []string{"Curves", "Color Balance"},
			},
			Impact: "high",
		})
		
		hidden = append(hidden, HiddenLayer{
			ID:   "hidden_2",
			Name: "Animation Timing Null",
			Type: "null_object",
			Properties: map[string]interface{}{
				"controls": []string{"speed", "offset", "loop"},
			},
			Impact: "medium",
		})
	}
	
	return hidden
}

// analyzeTextIntelligence performs smart text analysis
func (d *DangerousAnalyzer) analyzeTextIntelligence(metadata *ProjectMetadata) *TextLayerIntelligence {
	intel := &TextLayerIntelligence{
		TotalTextLayers:    len(metadata.TextLayers),
		DynamicFields:      []DynamicTextField{},
		PatternGroups:      make(map[string][]string),
		FormattingOptions:  []TextFormattingOption{},
		DataBindingOptions: []DataBindingOption{},
		LocalizationReady:  false,
	}
	
	// Analyze each text layer
	for _, text := range metadata.TextLayers {
		field := d.analyzeTextField(text)
		intel.DynamicFields = append(intel.DynamicFields, field)
		
		// Group by detected type
		if field.DetectedType != "" {
			intel.PatternGroups[field.DetectedType] = append(
				intel.PatternGroups[field.DetectedType], 
				field.LayerID,
			)
		}
	}
	
	// Check localization readiness
	intel.LocalizationReady = len(metadata.TextLayers) > 0 && 
		len(intel.PatternGroups["title"]) > 0
	
	// Generate formatting options
	intel.FormattingOptions = d.generateFormattingOptions()
	
	// Create data binding suggestions
	intel.DataBindingOptions = d.suggestDataBindings(intel.DynamicFields)
	
	return intel
}

// analyzeTextField intelligently analyzes a text field
func (d *DangerousAnalyzer) analyzeTextField(text TextLayerInfo) DynamicTextField {
	field := DynamicTextField{
		LayerID:      text.ID,
		FieldName:    d.generateFieldName(text.LayerName),
		DefaultValue: text.SourceText,
		MaxLength:    len(text.SourceText) * 2, // Allow 2x default length
	}
	
	// Detect type based on content and name
	field.DetectedType = d.detectTextType(text.LayerName, text.SourceText)
	
	// Set validation based on type
	switch field.DetectedType {
	case "date":
		field.ValidationRegex = `^\d{2}/\d{2}/\d{4}$`
		field.AllowedFormats = []string{"MM/DD/YYYY", "DD/MM/YYYY", "YYYY-MM-DD"}
	case "price":
		field.ValidationRegex = `^\$?\d+\.?\d{0,2}$`
		field.AllowedFormats = []string{"$X.XX", "X.XX", "$X"}
	case "email":
		field.ValidationRegex = `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
	case "phone":
		field.ValidationRegex = `^\+?\d{10,15}$`
		field.AllowedFormats = []string{"+1 (XXX) XXX-XXXX", "XXX-XXX-XXXX"}
	case "url":
		field.ValidationRegex = `^https?://[^\s]+$`
	default:
		field.ValidationRegex = `^.+$` // Any non-empty string
	}
	
	// Detect animation profile
	if text.IsAnimated {
		field.AnimationProfile = "typewriter"
	} else {
		field.AnimationProfile = "static"
	}
	
	return field
}

// generateFieldName creates a clean field name
func (d *DangerousAnalyzer) generateFieldName(layerName string) string {
	// Clean up layer name to create API-friendly field name
	name := strings.ToLower(layerName)
	name = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(name, "_")
	name = strings.Trim(name, "_")
	
	if name == "" {
		name = "text_field"
	}
	
	return name
}

// detectTextType intelligently detects the type of text
func (d *DangerousAnalyzer) detectTextType(name, content string) string {
	lowerName := strings.ToLower(name)
	lowerContent := strings.ToLower(content)
	
	// Check layer name first
	typePatterns := map[string][]string{
		"title":    {"title", "heading", "header", "h1", "h2"},
		"subtitle": {"subtitle", "subheading", "tagline"},
		"date":     {"date", "when", "time"},
		"price":    {"price", "cost", "amount", "$"},
		"email":    {"email", "mail", "@"},
		"phone":    {"phone", "tel", "mobile", "contact"},
		"url":      {"url", "link", "website", "www"},
		"cta":      {"cta", "button", "click", "action"},
		"body":     {"body", "description", "text", "paragraph"},
	}
	
	for textType, patterns := range typePatterns {
		for _, pattern := range patterns {
			if strings.Contains(lowerName, pattern) || strings.Contains(lowerContent, pattern) {
				return textType
			}
		}
	}
	
	// Content-based detection
	if matched, _ := regexp.MatchString(`\d{1,2}/\d{1,2}/\d{2,4}`, content); matched {
		return "date"
	}
	if matched, _ := regexp.MatchString(`\$\d+`, content); matched {
		return "price"
	}
	if strings.Contains(content, "@") && strings.Contains(content, ".") {
		return "email"
	}
	
	return "text"
}

// generateFormattingOptions creates text formatting choices
func (d *DangerousAnalyzer) generateFormattingOptions() []TextFormattingOption {
	return []TextFormattingOption{
		{
			Name: "Bold Title",
			Properties: map[string]interface{}{
				"fontWeight": "bold",
				"fontSize": "48px",
				"textTransform": "uppercase",
			},
			Preview: "BOLD TITLE",
		},
		{
			Name: "Elegant Script",
			Properties: map[string]interface{}{
				"fontFamily": "script",
				"fontSize": "36px",
				"fontStyle": "italic",
			},
			Preview: "Elegant Script",
		},
		{
			Name: "Modern Minimal",
			Properties: map[string]interface{}{
				"fontWeight": "300",
				"fontSize": "32px",
				"letterSpacing": "0.1em",
			},
			Preview: "Modern Minimal",
		},
	}
}

// suggestDataBindings creates data binding suggestions
func (d *DangerousAnalyzer) suggestDataBindings(fields []DynamicTextField) []DataBindingOption {
	bindings := []DataBindingOption{}
	
	for _, field := range fields {
		binding := DataBindingOption{
			FieldID:  field.LayerID,
			DataType: field.DetectedType,
			SourcePath: fmt.Sprintf("data.%s", field.FieldName),
			FallbackValue: field.DefaultValue,
		}
		
		// Add transformers based on type
		switch field.DetectedType {
		case "date":
			binding.Transformer = "dateFormat"
		case "price":
			binding.Transformer = "currency"
		case "text":
			if field.FieldName == "title" {
				binding.Transformer = "titleCase"
			}
		}
		
		bindings = append(bindings, binding)
	}
	
	return bindings
}

// analyzeMediaMapping creates comprehensive media mapping
func (d *DangerousAnalyzer) analyzeMediaMapping(metadata *ProjectMetadata) *MediaReplacementMapping {
	mapping := &MediaReplacementMapping{
		TotalAssets:       len(metadata.MediaAssets),
		ReplaceableAssets: []ReplaceableAsset{},
		AssetGroups:       make(map[string][]string),
		SmartSuggestions:  []MediaSuggestion{},
	}
	
	// Analyze each media asset
	for _, asset := range metadata.MediaAssets {
		if asset.IsPlaceholder || d.isLikelyReplaceable(asset) {
			replaceable := ReplaceableAsset{
				ID:              asset.ID,
				Name:            asset.Name,
				Type:            asset.Type,
				UsageLocations:  []string{"Main Comp"}, // Would need deeper analysis
				Requirements:    make(map[string]interface{}),
				ReplacementType: d.determineReplacementType(asset),
			}
			
			// Set requirements based on type
			switch asset.Type {
			case "image":
				replaceable.Requirements["format"] = []string{"jpg", "png"}
				replaceable.Requirements["minResolution"] = "1920x1080"
				replaceable.Dimensions = []int{1920, 1080} // Would extract from metadata
			case "video":
				replaceable.Requirements["format"] = []string{"mp4", "mov"}
				replaceable.Requirements["codec"] = "h264"
				replaceable.Duration = 5.0 // Would extract from metadata
			case "audio":
				replaceable.Requirements["format"] = []string{"mp3", "wav"}
				replaceable.Requirements["sampleRate"] = 44100
			}
			
			mapping.ReplaceableAssets = append(mapping.ReplaceableAssets, replaceable)
			
			// Group by type
			mapping.AssetGroups[asset.Type] = append(mapping.AssetGroups[asset.Type], asset.ID)
		}
	}
	
	// Generate smart suggestions
	mapping.SmartSuggestions = d.generateMediaSuggestions(mapping.ReplaceableAssets)
	
	return mapping
}

// isLikelyReplaceable checks if asset is likely replaceable
func (d *DangerousAnalyzer) isLikelyReplaceable(asset MediaAssetInfo) bool {
	replaceablePatterns := []string{
		"placeholder",
		"sample",
		"demo",
		"temp",
		"replace",
		"your.*here",
		"logo",
		"image\\d+",
		"video\\d+",
	}
	
	lowerName := strings.ToLower(asset.Name)
	for _, pattern := range replaceablePatterns {
		if matched, _ := regexp.MatchString(pattern, lowerName); matched {
			return true
		}
	}
	
	return false
}

// determineReplacementType identifies how asset should be replaced
func (d *DangerousAnalyzer) determineReplacementType(asset MediaAssetInfo) string {
	if asset.IsPlaceholder {
		return "direct"
	}
	
	if strings.Contains(strings.ToLower(asset.Name), "logo") {
		return "smart" // Smart replacement with scaling/positioning
	}
	
	return "conditional" // Conditional based on context
}

// generateMediaSuggestions creates intelligent suggestions
func (d *DangerousAnalyzer) generateMediaSuggestions(assets []ReplaceableAsset) []MediaSuggestion {
	suggestions := []MediaSuggestion{}
	
	for _, asset := range assets {
		if asset.Type == "image" && strings.Contains(asset.Name, "logo") {
			suggestion := MediaSuggestion{
				AssetID:    asset.ID,
				Suggestion: "Use company branding assets",
				Reasoning:  "Logo placeholder detected - recommend using brand guidelines",
				Confidence: 0.95,
				Alternatives: []string{
					"Brand logo (primary)",
					"Brand logo (secondary)",
					"Brand wordmark",
				},
			}
			suggestions = append(suggestions, suggestion)
		}
		
		if asset.Type == "video" && asset.ReplacementType == "direct" {
			suggestion := MediaSuggestion{
				AssetID:    asset.ID,
				Suggestion: "Use product demonstration video",
				Reasoning:  "Video placeholder matches product demo pattern",
				Confidence: 0.80,
				Alternatives: []string{
					"Product showcase",
					"Feature highlight reel",
					"Customer testimonial",
				},
			}
			suggestions = append(suggestions, suggestion)
		}
	}
	
	return suggestions
}

// analyzeEffectChains discovers effect combinations
func (d *DangerousAnalyzer) analyzeEffectChains(metadata *ProjectMetadata) []EffectChain {
	chains := []EffectChain{}
	
	// Group effects that commonly appear together
	if len(metadata.Effects) > 2 {
		chain := EffectChain{
			ID:           "chain_1",
			Name:         "Color Grading Stack",
			Effects:      []EffectNode{},
			Customizable: true,
			PerformanceImpact: d.assessPerformanceImpact(metadata.Effects),
			PresetOptions: d.generateEffectPresets(),
		}
		
		// Add common color effects
		for _, effect := range metadata.Effects {
			if d.isColorEffect(effect.Name) {
				node := EffectNode{
					Name: effect.Name,
					Parameters: map[string]interface{}{
						"intensity": 100,
						"blend_mode": "normal",
					},
					Keyframes: []Keyframe{},
				}
				chain.Effects = append(chain.Effects, node)
			}
		}
		
		if len(chain.Effects) > 0 {
			chains = append(chains, chain)
		}
	}
	
	return chains
}

// isColorEffect checks if effect is color-related
func (d *DangerousAnalyzer) isColorEffect(name string) bool {
	colorEffects := []string{
		"color", "tint", "hue", "saturation", "brightness",
		"contrast", "levels", "curves", "grade", "balance",
	}
	
	lowerName := strings.ToLower(name)
	for _, keyword := range colorEffects {
		if strings.Contains(lowerName, keyword) {
			return true
		}
	}
	
	return false
}

// assessPerformanceImpact evaluates render impact
func (d *DangerousAnalyzer) assessPerformanceImpact(effects []EffectInfo) string {
	totalUsage := 0
	for _, effect := range effects {
		totalUsage += effect.UsageCount
	}
	
	if totalUsage > 50 {
		return "high"
	} else if totalUsage > 20 {
		return "medium"
	}
	return "low"
}

// generateEffectPresets creates effect presets
func (d *DangerousAnalyzer) generateEffectPresets() []EffectPreset {
	return []EffectPreset{
		{
			Name:        "Cinematic Look",
			Description: "Film-style color grading",
			Parameters: map[string]interface{}{
				"contrast": 120,
				"saturation": 85,
				"highlights": -10,
				"shadows": 15,
			},
			Preview: "cinematic_preview.jpg",
		},
		{
			Name:        "Vibrant Pop",
			Description: "Bright, saturated colors",
			Parameters: map[string]interface{}{
				"saturation": 130,
				"vibrance": 125,
				"clarity": 110,
			},
			Preview: "vibrant_preview.jpg",
		},
		{
			Name:        "Vintage Film",
			Description: "Retro film aesthetic",
			Parameters: map[string]interface{}{
				"saturation": 70,
				"grain": 15,
				"vignette": 25,
			},
			Preview: "vintage_preview.jpg",
		},
	}
}

// generateAPISchema creates comprehensive API schema
func (d *DangerousAnalyzer) generateAPISchema(metadata *ProjectMetadata, analysis *DeepAnalysisResult) *AutoGeneratedAPISchema {
	schema := &AutoGeneratedAPISchema{
		Version:    "1.0.0",
		Endpoints:  []APIEndpoint{},
		DataModels: make(map[string]DataModel),
		Examples:   []APIExample{},
	}
	
	// Create render endpoint
	renderEndpoint := APIEndpoint{
		Method:      "POST",
		Path:        "/render",
		Description: "Render video with custom parameters",
		Parameters:  []APIParameter{},
		Response: map[string]interface{}{
			"job_id": "string",
			"status": "string",
			"eta": "number",
		},
	}
	
	// Add parameters based on discovered fields
	for _, field := range analysis.TextIntelligence.DynamicFields {
		param := APIParameter{
			Name:        field.FieldName,
			Type:        d.mapFieldTypeToAPI(field.DetectedType),
			Required:    false,
			Default:     field.DefaultValue,
			Description: fmt.Sprintf("%s field", field.DetectedType),
			Validation:  field.ValidationRegex,
		}
		renderEndpoint.Parameters = append(renderEndpoint.Parameters, param)
	}
	
	// Add media parameters
	for _, asset := range analysis.MediaMapping.ReplaceableAssets {
		param := APIParameter{
			Name:        fmt.Sprintf("%s_url", d.cleanAssetName(asset.Name)),
			Type:        "string",
			Required:    false,
			Description: fmt.Sprintf("URL for %s replacement", asset.Type),
			Validation:  "^https?://.+$",
		}
		renderEndpoint.Parameters = append(renderEndpoint.Parameters, param)
	}
	
	schema.Endpoints = append(schema.Endpoints, renderEndpoint)
	
	// Create data models
	schema.DataModels["RenderRequest"] = d.createRenderRequestModel(analysis)
	schema.DataModels["RenderResponse"] = d.createRenderResponseModel()
	
	// Add examples
	schema.Examples = d.generateAPIExamples(analysis)
	
	return schema
}

// mapFieldTypeToAPI maps detected type to API type
func (d *DangerousAnalyzer) mapFieldTypeToAPI(detectedType string) string {
	typeMap := map[string]string{
		"date":  "string",
		"price": "number",
		"email": "string",
		"phone": "string",
		"url":   "string",
		"text":  "string",
	}
	
	if apiType, ok := typeMap[detectedType]; ok {
		return apiType
	}
	return "string"
}

// cleanAssetName creates API-friendly asset name
func (d *DangerousAnalyzer) cleanAssetName(name string) string {
	clean := strings.ToLower(name)
	clean = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(clean, "_")
	clean = strings.Trim(clean, "_")
	return clean
}

// createRenderRequestModel creates request data model
func (d *DangerousAnalyzer) createRenderRequestModel(analysis *DeepAnalysisResult) DataModel {
	model := DataModel{
		Name:     "RenderRequest",
		Fields:   make(map[string]FieldDef),
		Required: []string{},
		Examples: []interface{}{},
	}
	
	// Add text fields
	for _, field := range analysis.TextIntelligence.DynamicFields {
		model.Fields[field.FieldName] = FieldDef{
			Type:        d.mapFieldTypeToAPI(field.DetectedType),
			Description: fmt.Sprintf("%s text content", field.DetectedType),
			Default:     field.DefaultValue,
			Validation:  field.ValidationRegex,
		}
	}
	
	// Add media fields
	for _, asset := range analysis.MediaMapping.ReplaceableAssets {
		fieldName := fmt.Sprintf("%s_url", d.cleanAssetName(asset.Name))
		model.Fields[fieldName] = FieldDef{
			Type:        "string",
			Description: fmt.Sprintf("URL for %s asset", asset.Type),
			Validation:  "^https?://.+$",
		}
	}
	
	// Add render options
	model.Fields["quality"] = FieldDef{
		Type:        "string",
		Description: "Render quality setting",
		Default:     "high",
		Validation:  "^(low|medium|high|ultra)$",
	}
	
	model.Fields["format"] = FieldDef{
		Type:        "string",
		Description: "Output format",
		Default:     "mp4",
		Validation:  "^(mp4|mov|webm)$",
	}
	
	return model
}

// createRenderResponseModel creates response data model
func (d *DangerousAnalyzer) createRenderResponseModel() DataModel {
	return DataModel{
		Name: "RenderResponse",
		Fields: map[string]FieldDef{
			"job_id": {
				Type:        "string",
				Description: "Unique job identifier",
			},
			"status": {
				Type:        "string",
				Description: "Current job status",
				Validation:  "^(queued|processing|completed|failed)$",
			},
			"progress": {
				Type:        "number",
				Description: "Progress percentage (0-100)",
			},
			"eta": {
				Type:        "number",
				Description: "Estimated time to completion in seconds",
			},
			"output_url": {
				Type:        "string",
				Description: "URL of rendered video (when completed)",
			},
			"error": {
				Type:        "string",
				Description: "Error message (if failed)",
			},
		},
		Required: []string{"job_id", "status"},
	}
}

// generateAPIExamples creates usage examples
func (d *DangerousAnalyzer) generateAPIExamples(analysis *DeepAnalysisResult) []APIExample {
	examples := []APIExample{}
	
	// Basic render example
	basicRequest := map[string]interface{}{
		"quality": "high",
		"format": "mp4",
	}
	
	// Add sample text values
	for _, field := range analysis.TextIntelligence.DynamicFields {
		if field.DetectedType == "title" {
			basicRequest[field.FieldName] = "Amazing Product Launch"
		} else if field.DetectedType == "date" {
			basicRequest[field.FieldName] = "12/25/2024"
		}
	}
	
	example := APIExample{
		Name:        "Basic Render",
		Description: "Simple video render with text replacements",
		Request:     basicRequest,
		Response: map[string]interface{}{
			"job_id": "job_123456",
			"status": "processing",
			"progress": 0,
			"eta": 120,
		},
	}
	
	examples = append(examples, example)
	
	return examples
}

// calculateComplexity scores project complexity
func (d *DangerousAnalyzer) calculateComplexity(result *DeepAnalysisResult) float64 {
	score := 0.0
	
	// Composition complexity
	for _, comp := range result.Metadata.Compositions {
		if comp.Is3D {
			score += 10
		}
		if comp.HasEffects {
			score += 5
		}
		score += float64(comp.LayerCount) * 0.5
	}
	
	// Effect complexity
	score += float64(len(result.EffectChains)) * 8
	
	// Modular complexity
	if result.ModularSystem != nil {
		score += float64(result.ModularSystem.TotalModules) * 3
		score += float64(len(result.ModularSystem.Relationships)) * 2
	}
	
	// Hidden layer complexity
	score += float64(len(result.HiddenLayers)) * 5
	
	// Normalize to 0-100
	maxScore := 200.0
	normalized := (score / maxScore) * 100
	if normalized > 100 {
		normalized = 100
	}
	
	return normalized
}

// calculateAutomationPotential scores automation opportunities
func (d *DangerousAnalyzer) calculateAutomationPotential(result *DeepAnalysisResult) float64 {
	score := 0.0
	
	// Text automation potential
	if result.TextIntelligence != nil {
		score += float64(result.TextIntelligence.TotalTextLayers) * 5
		if result.TextIntelligence.LocalizationReady {
			score += 20
		}
		score += float64(len(result.TextIntelligence.DataBindingOptions)) * 3
	}
	
	// Media automation potential
	if result.MediaMapping != nil {
		score += float64(len(result.MediaMapping.ReplaceableAssets)) * 4
		score += float64(len(result.MediaMapping.SmartSuggestions)) * 2
	}
	
	// Modular automation potential
	if result.ModularSystem != nil && result.ModularSystem.TotalModules > 2 {
		score += 30
		score += float64(result.ModularSystem.VariantPotential) * 2
	}
	
	// API readiness
	if result.APISchema != nil {
		score += 20
	}
	
	// Normalize to 0-100
	maxScore := 150.0
	normalized := (score / maxScore) * 100
	if normalized > 100 {
		normalized = 100
	}
	
	return normalized
}

// generateRecommendations creates actionable recommendations
func (d *DangerousAnalyzer) generateRecommendations(result *DeepAnalysisResult) []AutomationRecommendation {
	recommendations := []AutomationRecommendation{}
	
	// Text automation recommendation
	if result.TextIntelligence != nil && result.TextIntelligence.TotalTextLayers > 3 {
		rec := AutomationRecommendation{
			Type:        "text_automation",
			Title:       "Implement Dynamic Text System",
			Description: fmt.Sprintf("Automate %d text layers for dynamic content generation", result.TextIntelligence.TotalTextLayers),
			Impact:      "high",
			Effort:      "low",
			ROI:         0.85,
			Steps: []string{
				"Export text field mapping",
				"Create data input interface",
				"Implement validation rules",
				"Set up batch processing",
			},
		}
		recommendations = append(recommendations, rec)
	}
	
	// Modular system recommendation
	if result.ModularSystem != nil && result.ModularSystem.TotalModules > 2 {
		rec := AutomationRecommendation{
			Type:        "modular_system",
			Title:       "Build Modular Video System",
			Description: fmt.Sprintf("Create mix-and-match system with %d modules", result.ModularSystem.TotalModules),
			Impact:      "high",
			Effort:      "medium",
			ROI:         0.75,
			Steps: []string{
				"Catalog modular components",
				"Define combination rules",
				"Build selection interface",
				"Implement render pipeline",
			},
		}
		recommendations = append(recommendations, rec)
	}
	
	// Media automation recommendation
	if result.MediaMapping != nil && len(result.MediaMapping.ReplaceableAssets) > 2 {
		rec := AutomationRecommendation{
			Type:        "media_automation",
			Title:       "Automated Media Replacement",
			Description: fmt.Sprintf("Enable dynamic replacement of %d media assets", len(result.MediaMapping.ReplaceableAssets)),
			Impact:      "medium",
			Effort:      "medium",
			ROI:         0.65,
			Steps: []string{
				"Define media requirements",
				"Create upload interface",
				"Implement asset validation",
				"Build replacement engine",
			},
		}
		recommendations = append(recommendations, rec)
	}
	
	// API development recommendation
	if result.AutomationScore > 60 {
		rec := AutomationRecommendation{
			Type:        "api_development",
			Title:       "Develop Render API",
			Description: "Create RESTful API for programmatic video generation",
			Impact:      "high",
			Effort:      "high",
			ROI:         0.80,
			Steps: []string{
				"Implement API endpoints",
				"Create authentication system",
				"Build job queue system",
				"Deploy to cloud infrastructure",
			},
		}
		recommendations = append(recommendations, rec)
	}
	
	return recommendations
}

// ToJSON exports the analysis as JSON
func (r *DeepAnalysisResult) ToJSON() ([]byte, error) {
	return json.MarshalIndent(r, "", "  ")
}

// GenerateReport creates a human-readable report
func (r *DeepAnalysisResult) GenerateReport() string {
	report := fmt.Sprintf(`# Deep Analysis Report

Generated: %s
File: %s

## Executive Summary

- **Complexity Score**: %.1f/100
- **Automation Potential**: %.1f/100
- **Total Opportunities**: %d

`, time.Now().Format("2006-01-02 15:04:05"), 
   r.Metadata.FileName, 
   r.ComplexityScore, 
   r.AutomationScore,
   len(r.Metadata.Opportunities))

	// Modular System
	if r.ModularSystem != nil && r.ModularSystem.TotalModules > 0 {
		report += fmt.Sprintf(`## Modular System Analysis

- **Total Modules**: %d
- **Variant Potential**: %d combinations
- **Mix & Match Options**: %d

### Discovered Components:
`, r.ModularSystem.TotalModules, 
   r.ModularSystem.VariantPotential,
   len(r.ModularSystem.MixMatchOptions))

		for _, comp := range r.ModularSystem.ModularComponents {
			report += fmt.Sprintf("- %s (%s) - %s complexity\n", 
				comp.Name, comp.Type, comp.ComplexityLevel)
		}
		report += "\n"
	}

	// Text Intelligence
	if r.TextIntelligence != nil && r.TextIntelligence.TotalTextLayers > 0 {
		report += fmt.Sprintf(`## Text Layer Intelligence

- **Total Text Layers**: %d
- **Dynamic Fields**: %d
- **Localization Ready**: %v

### Field Types Detected:
`, r.TextIntelligence.TotalTextLayers,
   len(r.TextIntelligence.DynamicFields),
   r.TextIntelligence.LocalizationReady)

		for fieldType, layers := range r.TextIntelligence.PatternGroups {
			report += fmt.Sprintf("- **%s**: %d layers\n", fieldType, len(layers))
		}
		report += "\n"
	}

	// Recommendations
	if len(r.Recommendations) > 0 {
		report += "## Automation Recommendations\n\n"
		for i, rec := range r.Recommendations {
			report += fmt.Sprintf(`### %d. %s

**Impact**: %s | **Effort**: %s | **ROI**: %.0f%%

%s

**Implementation Steps**:
`, i+1, rec.Title, rec.Impact, rec.Effort, rec.ROI*100, rec.Description)

			for _, step := range rec.Steps {
				report += fmt.Sprintf("1. %s\n", step)
			}
			report += "\n"
		}
	}

	return report
}

// GenerateAPIDocumentation creates API documentation
func (r *DeepAnalysisResult) GenerateAPIDocumentation() string {
	if r.APISchema == nil {
		return "No API schema generated"
	}

	doc := fmt.Sprintf(`# Auto-Generated API Documentation

Version: %s

## Endpoints

`, r.APISchema.Version)

	for _, endpoint := range r.APISchema.Endpoints {
		doc += fmt.Sprintf(`### %s %s

%s

**Parameters**:
`, endpoint.Method, endpoint.Path, endpoint.Description)

		for _, param := range endpoint.Parameters {
			required := ""
			if param.Required {
				required = " *(required)*"
			}
			doc += fmt.Sprintf("- **%s** (%s)%s: %s\n", 
				param.Name, param.Type, required, param.Description)
			if param.Default != nil {
				doc += fmt.Sprintf("  - Default: `%v`\n", param.Default)
			}
			if param.Validation != "" {
				doc += fmt.Sprintf("  - Validation: `%s`\n", param.Validation)
			}
		}
		doc += "\n"
	}

	// Add examples
	if len(r.APISchema.Examples) > 0 {
		doc += "## Examples\n\n"
		for _, example := range r.APISchema.Examples {
			doc += fmt.Sprintf("### %s\n\n%s\n\n", example.Name, example.Description)
			doc += "**Request**:\n```json\n"
			req, _ := json.MarshalIndent(example.Request, "", "  ")
			doc += string(req) + "\n```\n\n"
			doc += "**Response**:\n```json\n"
			resp, _ := json.MarshalIndent(example.Response, "", "  ")
			doc += string(resp) + "\n```\n\n"
		}
	}

	return doc
}

// GetHashID generates a unique hash for the analysis
func (r *DeepAnalysisResult) GetHashID() string {
	data := fmt.Sprintf("%s_%f_%f_%d", 
		r.Metadata.FileName,
		r.ComplexityScore,
		r.AutomationScore,
		len(r.Recommendations))
	
	hash := md5.Sum([]byte(data))
	return hex.EncodeToString(hash[:])
}